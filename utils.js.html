<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var utils = module.exports = {
  
  /**
   * Check whether the given object is an instance of the specified class.
   * The necessity for this is discussed in PR #13: https://github.com/rootsdev/gedcomx-js/pull/13
   * 
   * We put this functionality in a method to be DRY, even though it's short.
   * This could easily change in the future for correction and performance.
   * 
   * It could be handy to expose this on GedcomX somewhere so that users of the
   * library can use it too. But then we would need to add a way for them to
   * easily get the _gedxClass property without being tied to that private
   * property name. In other words, a static method such as Person.getClass()
   * 
   * @param {Object} obj
   * @param {String} className
   * @returns {Boolean}
   */
  isInstance: function(obj, className){
    return obj &amp;&amp; Object.getPrototypeOf(obj) !== Object.prototype &amp;&amp; obj._gedxClass === className;
  },
  
  /**
   * Returns a copy of the object with undefined attributes removed.
   * 
   * @param {Object} object
   * @return {Object}
   */
  removeEmpty: function(object){
    var dest = {};
    for(var a in object){
      if(object.hasOwnProperty(a) &amp;&amp; object[a] !== undefined){
        dest[a] = object[a];
      }
    }
    return dest;
  },
  
  /**
   * Returns an object containing the properties from the source object
   * 
   * @param {Object} obj
   * @param {String[]} properties
   * @return {Object}
   */
  pick: function(object, properties){
    var dest = {},
        attr;
    for(var i = 0; i &lt; properties.length; i++){
      attr = properties[i];
      if(object.hasOwnProperty(attr)){
        dest[attr] = object[attr];
      }
    }
    return dest;
  },
  
  /**
   * Merge multiple objects
   * 
   * Inspired by http://stackoverflow.com/a/16178864
   * 
   * @param {Object} destination
   * @param {Object} source
   * @param {Object=} source
   */
  merge: function(){
    var args = [].splice.call(arguments, 0),
        dest = args.shift(),
        src, attr;
    while(args.length > 0){
      src = args.shift();
      if(typeof src === 'object'){
        for(attr in src){
          if(src.hasOwnProperty(attr)){
            if(typeof src[attr] === 'object' &amp;&amp; !Array.isArray(src[attr])){
              dest[attr] = utils.merge(dest[attr] || {}, src[attr]);
            } else {
              dest[attr] = src[attr];
            }
          }
        }
      }
    }
    return dest;
  },
  
  /**
   * Recursively calls .toJSON() on values in an object that have the .toJSON()
   * method defined.
   * 
   * @param {Object} object
   * @return {Object}
   */
  toJSON: function(object){
    
    // Arrays - recursively call utils.toJSON() on the array items
    if(Array.isArray(object)){
      return object.map(function(o){
        return utils.toJSON(o);
      });
    }
    
    // All remaining non-objects - just return them
    if(typeof object !== 'object'){
      return object;
    }
    
    // At this point we only have objects
    var dest = {},
        value;
    for(var a in object){
      if(object.hasOwnProperty(a)){
        value = object[a];
        
        // Skip undefined values
        if(typeof value === 'undefined'){
          continue;
        }
        
        // Dates - get their time. We have to deal with dates down here instead
        // of above because Date has a native toJSON method, meaning it would
        // be cause by the case below and have the method called but we don't
        // want to call the native method because it returns an ISO string while
        // GEDCOMX requires a timestamp.
        else if(typeof value.getTime === 'function'){
          dest[a] = value.getTime();
        }
        
        // Call the object's .toJSON() method if it's available
        else if (typeof value.toJSON === 'function'){
          dest[a] = value.toJSON();
        } 
        
        // Otherwise we recursively call utils.toJSON() on the value
        else {
          dest[a] = utils.toJSON(value);
        }
      }
    }
    return dest;
  }
  
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a></li><li><a href="GedcomX.html">GedcomX</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Fri Oct 07 2016 14:57:24 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
